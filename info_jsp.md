Коротко: это JSP-бекдор-загрузчик (memory webshell). Он принимает зашифрованный байткод по HTTP POST, расшифровывает его, в памяти создаёт класс и тут же исполняет — без записи на диск и без видимого ответа. Это даёт атакующему удалённое выполнение кода через «тихий» канал.

Что делает по шагам

1. Работает **только на POST**:

* читает весь бинарный тело запроса из `request.getInputStream()`.

2. **Декодирует и расшифровывает**:

* сначала Base64 (`java.util.Base64`, а если нет — `sun.misc.BASE64Decoder` как запасной вариант);
* затем XOR по кругу ключом `e1b79db1a81d86f5` (16 байт), индекс `(i + 1) & 15` — т.е. ключ берётся циклически, но со сдвигом на +1.

3. **Грузит класс в память и исполняет**:

* кастомный `ClassLoader` (`U`) вызывает `defineClass(...)`;
* создаёт инстанс и вызывает у него `equals(pageContext)`.
  Это трюк, характерный для семейств вебшеллов вроде Behinder/“冰蝎”/Godzilla: входная точка замаскирована под `equals(...)`, чтобы обходить простые детекторы.

Что это даёт атакующему

* Возможность отправлять каждый раз **новый «пейлоад» в виде Base64+XOR-класса** и выполнять его на сервере.
* Код живёт **только в памяти** (меньше следов на диске).
* Ключ `e1b79db1a81d86f5` — «секрет», которым шифруют загружаемый класс. Без него загрузчик не выполнит пейлоад.

Как провести быструю форензику (безопасно, оффлайн)

* Возьмите тело подозрительного POST к этому JSP.
* Base64-декодируйте.
* Сделайте XOR каждого байта с циклическим ключом `e1b79db1a81d86f5`, беря байт ключа по индексу `(i+1) & 15`.
* Получите .class и просмотрите `javap -c`/декомпилятором — так увидите, что именно запускали.

Индикаторы/признаки

* В файлах JSP/Java встречается строка ключа `e1b79db1a81d86f5`.
* Конструкция `new ClassLoader(...).defineClass(...)` или похожий самописный загрузчик.
* В коде вызов `newInstance().equals(pageContext)`.
* В логах — POST-запросы к конкретному JSP без видимого контента в ответе, с телом Base64.

Что делать прямо сейчас (mitigation)

* Удалите/изолируйте файл JSP и перезапустите контейнер (Tomcat/Jetty и т.п.), очистите `work/` (скомпилированные JSP).
* Проверьте весь веб-каталог на похожие фрагменты (ключ, `defineClass`, `equals(pageContext)`).
* Просмотрите access-/audit-логи на POST к этому пути, заодно извлеките тела для анализа (см. шаг выше).
* Ротуйте учётки/секреты, проверьте на пост-эксплойт (новые админ-пользователи, web.xml фильтры, планировщики, crontab и т.п.).
* Включите WAF/правила на блокировку POST к статическим/внешним JSP, ограничьте выполнение только нужных эндпоинтов.
* Обновите контейнер и отключите устаревшие классы (`sun.misc.BASE64Decoder`), где это возможно, ужесточите политику загрузчиков/секьюрити-менеджера (в современных JVM — политики модулей, ограничение `defineClass` сторонним кодом).

Если нужно, могу прямо сейчас помочь:

* извлечь и разобрать конкретный пейлоад из вашего трафика/логов,
* накидать простые сигнатуры для поиска таких JSP по проекту,
* составить краткую памятку по проверкам после компрометации.
